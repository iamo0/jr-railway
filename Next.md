# Особенности Next.js

React — это фреймворк для __отображения__
Но существуют другие задачи:
  - скачивание данных
  - роутинг — отображение разных файлов для разных урлов (страниц)
    - локальный сервер
    - роуты
    - каждый из роутов создает HTML страницу, каждая из которых запускает свой JS

Как это решается в Next.js
1. В Next.js этот процесс инкапсулирован
2. App Routes — при запуске локального сервера страницы генерируются автоматически на основе структуры файлов
  - Нужна папка `src/app`
  - Каждая новая директория внутри этой папки — это новый адрес для сервера
  - Каждый файл `page.tsx` внутри папки с роутом — это входная точка
3. Общая структура страницы берется из ближайшего файла `layout.tsx`

## Подключение стилей
### Простой импорт
В начале модуля, который описывает страницу подключаем стили через `import`

```tsx
import "./styles.css";
```

### Сложный импорт
В начале модуля, который описывает страницу подключаем стили через `import`
файла со специальным неймингом: `<filename>.module.css` и импортируем стили 
в объем с любым названием, обычно `styles`

```tsx 
import styles from "./filename.module.css";
```

При таком способе подключения название каждого класса подключается как свойство
объекта `styles` в `className`. Это дает возможность обфусцировать имена
классов и использовать простанства имен в CSS (например, делать 10 разных
классов `.header` каджый из которых не повлияет на соседние модули)

## "use client";
Next.js — это SSR фреймворк. Это значит, что он выполняется и на сервере
и на клиенте (SSR — Server Side Rendering).

Из этого вытекает, что одна и та же функция на React (компонент) может 
быть вызвана как React-компонент, так и как функция для отрисовки шаблона 
на серверной стороне:
  - в случае клиентского рендеринга React отрисовывает компонент в виртуальное 
    DOM-дерево
  - в случае серверного рендеринга React отрисовывает компонент в виде строки,
    содержащей HTML-разметку

```jsx
// index.js запускается через Node.js

express.get("/", function(req, res) {
  res.status(200).send(React.render(<html>
    <RadioButton className="asd" />
  </html>));
});
```

Одни и те же компоненты могут использоваться и на сервере и на клиенте, но в этом
случае нужно, чтобы эти компоненты не использовали специфичный для платформы код,
т.е., например, не обращались к браузерному API (document, window, history, 
обработчики событий) и не были интерактивными (не использовали useState, useReducer)

Поэтому, если у вас компонент специфичен для платформы, нужно использовать
соотв. директиву:
- "use client"; в начале файла, если это интерактивный компонент (использует
  обработчики события или useState)
- import "server-only"; если это __строго__ серверный компонент и его код не должен
  оказатсья на клиенте

## Uncontolled and controlled inputs
Инпуты (<input type="*" />) в React бывают двух видов:
- те, у которых есть только начальное `value`, но изменение этого `value` не влечет
  за собой изменений в других компонентах (Uncontolled — неконтролируемые)

- те, `value` которых завязан на внешние значения или изменения `value` которых
  изменяют некоторые внешние значения (Controlled — контролируемые)

```jsx
function someComponent() {
  function handleChange() {
    return;
  };

  const someVariable = 1;
  return <input type="text" value={someVariable} onChange={handleChange} />
}
```

Контролируемые компоненты называются так, из-за того, что в компонентах вам нужно
контролировать не только начальное состояние, но и цикл обратной связи: если
вы задаете `value` у инпута, то его можно поменять на лету. 

Если вы используете вычисляемое из какого-то внешнего значения `value` у вас происходит
логическое противоречие, которое React не знает как разрешить, потому что любой
инпут можно редактировать и по умолчанию непонятно, что делать с исходным значением

Поэтому, если вы используете компонент у которого в качестве `value` прописано
внешнее значение, этот инпут должен:
- или быть readOnly (в таком случае логическое противоречие исчезает)
- или иметь описанное свойство `onChange` (но в этом случае нужно помнить, что
  в обработчик события попадет настоящее DOM-событие, в котором можно будет обратиться
  к настоящему DOM-элементу и могут возникнуть странные случаи, когда у вас есть,
  например два `value` и это разные `value`, потому что одно из них из виртуального
  DOM-дерева, а второе — из настоящего)

## useReducer vs useState
1. `useState` используется если значение атомарное или примитивного типа
2. `useReducer` используется если значение сложное

```jsx
function Component({ defaultValue }) {
  const [searchString, setSearchString] = useState(defaultValue);
  const [searchParams, setSearchParams] = useReducer();

  const handleChange = function handleChange(evt) {
    setSearchString(evt.target.value);
  };

  return <input type="search" value={searchString} onChange={handleChange} />
}
```

Функция обновления значения в `state` обновляет значение целиком

Функция обновления значения в редьюсере обновляет значение точечно

```jsx
function UserSettings() {
  // Императивный стиль — управление состоянием происходит явно, вам
  // нужно полностью контролировать способ вызова и работу функции
  const [userSettingsState, setUserSettings] = useState({
    isDarkTheme: false,
    isNotificationsEnabled: false,
    username: "iamo0",
    userpic: "/public/iamo0.svg",
    preferredTheme: "monokai",
    favoriteHotels: [],
  });

  setUserSettings({
    ...userSettingsState,
    favoriteHotels: [...userSettingsState.favoriteHotels, "123"],
  });

  // Декларативный стиль — управление состоянием производится неявно
  // (в сторого определенном контролируемом контексте), а вызов изменения
  // состояния скорее является "запросом" на изменение этого состояния
  // чем прямым управлением
  const [userSettings, dispatch] = useReducer(userSettingsReducer, {
    isDarkTheme: false,
    isNotificationsEnabled: false,
    username: "iamo0",
    userpic: "/public/iamo0.svg",
    preferredTheme: "monokai",
    favoriteHotels: [],
  });

  dispatch({
    action: "ADD_FAVORITE_HOTEL",
    payload: {
      id: "123",
    },
  });
}
```

## Асинхронность и `useEffect`
Функция, обновляющая состояние, взятое из `useState` в React, асинхронна.
Когда меняется `state` компонента этот компонент нужно немедленно отрисовать 
заново. Отрисовка компонента заново в терминах функциональных компонент (
компонент-функция, те самое компоненты, которые мы обычно пишем) означает
новый вызов функции, это значит, что если обратиться к состоянию сразу 
после вызова функции обновления, в состоянии будет записано еще старое значение

```jsx
const [state, setState] = useState(0);
setState(1);
console.log(state); // вернет 0
```

Функция `useEffect` используется как обработчик события для наблюдения
за изменяемыми значениями, которые хранятся в `state`. После изменения
значения в `state`. Функция `useEffect` вызывается после каждого рендера 
(вызов функции), связанного с массивом значений (или с первым рендером
вообще). Поэтому, если вы используете `useEffect`, то первый его вызов
произойдет как только компонент отрисуется, а последующие — при изменении
значений массива зависимостей

```jsx
const [state, setState] = useState(0);
setState(1);

useEffect(function() {
  // Сработает два раза: вернет сначала 0, потом 1
  console.log(state);
});
```

## Трюк для условного рендеринга в React
Бывает так, что иногда вам нужно не отрисовывать определенный компонент
в зависимости от определенных условий

```jsx
// Неправильный подход, потому что тут генерируются два дерева
if (userIsLoggedIn) {
  return <header>
    Header stuff
  </header>
}

return <header>
  <Button>Log in</Button>
  Header stuff
</header>

```

Сравним два подхода к удалению элементов из дерева:

```
I. Прямое удаление
1 2 3 4 5
1 3 4 5
===
1 1
2 3
3 4
4 5
5

II. Пометка как удаленного
1 2    3 4 5
1 null 3 4 5

1 1
2 null
3 3
4 4
5 5
```

```jsx
return <header>
  Header stuff
  {isUserLoggedIn ?
    null :
    <Button>Log in</Button>}
</header>
```




