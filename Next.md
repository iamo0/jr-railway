# Особенности Next.js

React — это фреймворк для __отображения__
Но существуют другие задачи:
  - скачивание данных
  - роутинг — отображение разных файлов для разных урлов (страниц)
    - локальный сервер
    - роуты
    - каждый из роутов создает HTML страницу, каждая из которых запускает свой JS

Как это решается в Next.js
1. В Next.js этот процесс инкапсулирован
2. App Routes — при запуске локального сервера страницы генерируются автоматически на основе структуры файлов
  - Нужна папка `src/app`
  - Каждая новая директория внутри этой папки — это новый адрес для сервера
  - Каждый файл `page.tsx` внутри папки с роутом — это входная точка
3. Общая структура страницы берется из ближайшего файла `layout.tsx`

## Подключение стилей
### Простой импорт
В начале модуля, который описывает страницу подключаем стили через `import`

```tsx
import "./styles.css";
```

### Сложный импорт
В начале модуля, который описывает страницу подключаем стили через `import`
файла со специальным неймингом: `<filename>.module.css` и импортируем стили 
в объем с любым названием, обычно `styles`

```tsx 
import styles from "./filename.module.css";
```

При таком способе подключения название каждого класса подключается как свойство
объекта `styles` в `className`. Это дает возможность обфусцировать имена
классов и использовать простанства имен в CSS (например, делать 10 разных
классов `.header` каджый из которых не повлияет на соседние модули)

## "use client";
Next.js — это SSR фреймворк. Это значит, что он выполняется и на сервере
и на клиенте (SSR — Server Side Rendering).

Из этого вытекает, что одна и та же функция на React (компонент) может 
быть вызвана как React-компонент, так и как функция для отрисовки шаблона 
на серверной стороне:
  - в случае клиентского рендеринга React отрисовывает компонент в виртуальное 
    DOM-дерево
  - в случае серверного рендеринга React отрисовывает компонент в виде строки,
    содержащей HTML-разметку

```jsx
// index.js запускается через Node.js

express.get("/", function(req, res) {
  res.status(200).send(React.render(<html>
    <RadioButton className="asd" />
  </html>));
});
```

Одни и те же компоненты могут использоваться и на сервере и на клиенте, но в этом
случае нужно, чтобы эти компоненты не использовали специфичный для платформы код,
т.е., например, не обращались к браузерному API (document, window, history, 
обработчики событий) и не были интерактивными (не использовали useState, useReducer)

Поэтому, если у вас компонент специфичен для платформы, нужно использовать
соотв. директиву:
- "use client"; в начале файла, если это интерактивный компонент (использует
  обработчики события или useState)
- import "server-only"; если это __строго__ серверный компонент и его код не должен
  оказатсья на клиенте

## Uncontolled and controlled inputs
Инпуты (<input type="*" />) в React бывают двух видов:
- те, у которых есть только начальное `value`, но изменение этого `value` не влечет
  за собой изменений в других компонентах (Uncontolled — неконтролируемые)

- те, `value` которых завязан на внешние значения или изменения `value` которых
  изменяют некоторые внешние значения (Controlled — контролируемые)

```jsx
function someComponent() {
  function handleChange() {
    return;
  };

  const someVariable = 1;
  return <input type="text" value={someVariable} onChange={handleChange} />
}
```

Контролируемые компоненты называются так, из-за того, что в компонентах вам нужно
контролировать не только начальное состояние, но и цикл обратной связи: если
вы задаете `value` у инпута, то его можно поменять на лету. 

Если вы используете вычисляемое из какого-то внешнего значения `value` у вас происходит
логическое противоречие, которое React не знает как разрешить, потому что любой
инпут можно редактировать и по умолчанию непонятно, что делать с исходным значением

Поэтому, если вы используете компонент у которого в качестве `value` прописано
внешнее значение, этот инпут должен:
- или быть readOnly (в таком случае логическое противоречие исчезает)
- или иметь описанное свойство `onChange` (но в этом случае нужно помнить, что
  в обработчик события попадет настоящее DOM-событие, в котором можно будет обратиться
  к настоящему DOM-элементу и могут возникнуть странные случаи, когда у вас есть,
  например два `value` и это разные `value`, потому что одно из них из виртуального
  DOM-дерева, а второе — из настоящего)

