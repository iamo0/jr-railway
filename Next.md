# Особенности Next.js

React — это фреймворк для __отображения__
Но существуют другие задачи:
  - скачивание данных
  - роутинг — отображение разных файлов для разных урлов (страниц)
    - локальный сервер
    - роуты
    - каждый из роутов создает HTML страницу, каждая из которых запускает свой JS

Как это решается в Next.js
1. В Next.js этот процесс инкапсулирован
2. App Routes — при запуске локального сервера страницы генерируются автоматически на основе структуры файлов
  - Нужна папка `src/app`
  - Каждая новая директория внутри этой папки — это новый адрес для сервера
  - Каждый файл `page.tsx` внутри папки с роутом — это входная точка
3. Общая структура страницы берется из ближайшего файла `layout.tsx`

## Подключение стилей
### Простой импорт
В начале модуля, который описывает страницу подключаем стили через `import`

```tsx
import "./styles.css";
```

### Сложный импорт
В начале модуля, который описывает страницу подключаем стили через `import`
файла со специальным неймингом: `<filename>.module.css` и импортируем стили 
в объем с любым названием, обычно `styles`

```tsx 
import styles from "./filename.module.css";
```

При таком способе подключения название каждого класса подключается как свойство
объекта `styles` в `className`. Это дает возможность обфусцировать имена
классов и использовать простанства имен в CSS (например, делать 10 разных
классов `.header` каджый из которых не повлияет на соседние модули)

## "use client";
Next.js — это SSR фреймворк. Это значит, что он выполняется и на сервере
и на клиенте (SSR — Server Side Rendering).

Это значит, что у Next.js существует свой HTTP-сервер
  - BFF (Backend for frontend)
    - Роутинг в Next.js происходит еще на сервере
    - Отрисовывает бандл на сервере

    ```
      express.get("/", function(req, res) {
        res.status(200).send(<Home />);
      });

      express.get("/search", function(req, res) {
        const { search } = request;
        res.status(200).send(<Page {...search} />);
      });
    ```

    - SSG => Static Site Generation. В случа если у нас тстраница
      не будет перерисована в зависимости от пользовательского
      запроса и ее исходная разметка будет всегда одинаковой,
      вместо того, чтобы генерировать ее исходный код каждый
      раз при новом запросе, мы генерируем ее исходный код
      единожды, во время выполнения кодманды `next build`, после
      этого в HTTP запросах будет всегда отдаваться статический
      HTML

  - Отдаваемые куски JS

Из этого вытекает, что одна и та же функция на React (компонент) вызывается 
как React-компонент, так и как функция для отрисовки шаблона 
на серверной стороне:
  - в случае клиентского рендеринга React отрисовывает компонент в виртуальное 
    DOM-дерево
  - в случае серверного рендеринга React отрисовывает компонент в виде строки,
    содержащей HTML-разметку

```jsx
// index.jsx запускается через Node.js

express.get("/", function(req, res) {
  res.status(200).send(ReactDOMServer.renderToString(<html>
    <RadioButton className="asd" />
  </html>));
});
```


```jsx
// page1.tsx
// Роут /
function Page() {
  const [siteOwner, setSiteOwner] = useState("our");

  function handleClick() {
    setSiteOwner("your");
  }

  return <div>
    <h1>Hello, from {siteOwner} site</h1>
    <Link onClick={handleClick} href="/page2">2</Link />
  </div>;
} => `
  <div>
    <h1>Hello, from <span>our</span> site</h1>
    <a href="/page2">2</a>
  </div>
  <script src="./page1.tsx"></script>
`;

// page2.tsx
// Роут /page2
function Page() {
  return <div>
    <h1>I'm here</h1>
  </div>;
}

/*
 1. Клиент делает запрос на /
 2. Сервер открывает файл page1.tsx и выполняет его на сервере, получает
    строку, содержащую HTML и этот HTML отправляется на клиент вметсе
    со скриптом, который содержит код страницы
 3. После этого у нас происходит процесс, который называется hydration 
    (гидратация) 
      - React это библиотека, которая нужна для того, чтобы создавать
        виртуальные DOM-деревья для быстрого динамического обновления
      - После SSR React отдает еще и код компонента
      - Генерирует по этому коду виртуальное DOM-дерево
      - Гидратация — это процесс при котором React "натравливается" 
        на существующий DOM
*/

```

Одни и те же компоненты используются и на сервере и на клиенте, но в этом
случае нужно, чтобы эти компоненты не использовали специфичный для платформы код,
т.е., например, не обращались к браузерному API (document, window, history, 
обработчики событий) и не были интерактивными (не использовали useState, useReducer)

Поэтому, если у вас компонент специфичен для платформы, нужно использовать
соотв. директиву:
- "use client"; в начале файла, если это интерактивный компонент (использует
  обработчики события или useState)
- import "server-only"; если это __строго__ серверный компонент и его код не должен
  оказатсья на клиенте

## Uncontolled and controlled inputs
Инпуты (<input type="*" />) в React бывают двух видов:
- те, у которых есть только начальное `value`, но изменение этого `value` не влечет
  за собой изменений в других компонентах (Uncontolled — неконтролируемые)

- те, `value` которых завязан на внешние значения или изменения `value` которых
  изменяют некоторые внешние значения (Controlled — контролируемые)

```jsx
function someComponent() {
  function handleChange() {
    return;
  };

  const someVariable = 1;
  return <input type="text" value={someVariable} onChange={handleChange} />
}
```

Контролируемые компоненты называются так, из-за того, что в компонентах вам нужно
контролировать не только начальное состояние, но и цикл обратной связи: если
вы задаете `value` у инпута, то его можно поменять на лету. 

Если вы используете вычисляемое из какого-то внешнего значения `value` у вас происходит
логическое противоречие, которое React не знает как разрешить, потому что любой
инпут можно редактировать и по умолчанию непонятно, что делать с исходным значением

Поэтому, если вы используете компонент у которого в качестве `value` прописано
внешнее значение, этот инпут должен:
- или быть readOnly (в таком случае логическое противоречие исчезает)
- или иметь описанное свойство `onChange` (но в этом случае нужно помнить, что
  в обработчик события попадет настоящее DOM-событие, в котором можно будет обратиться
  к настоящему DOM-элементу и могут возникнуть странные случаи, когда у вас есть,
  например два `value` и это разные `value`, потому что одно из них из виртуального
  DOM-дерева, а второе — из настоящего)

## useReducer vs useState
1. `useState` используется если значение атомарное или примитивного типа
2. `useReducer` используется если значение сложное

```jsx
function Component({ defaultValue }) {
  const [searchString, setSearchString] = useState(defaultValue);
  const [searchParams, setSearchParams] = useReducer();

  const handleChange = function handleChange(evt) {
    setSearchString(evt.target.value);
  };

  return <input type="search" value={searchString} onChange={handleChange} />
}
```

Функция обновления значения в `state` обновляет значение целиком

Функция обновления значения в редьюсере обновляет значение точечно

```jsx
function UserSettings() {
  // Императивный стиль — управление состоянием происходит явно, вам
  // нужно полностью контролировать способ вызова и работу функции
  const [userSettingsState, setUserSettings] = useState({
    isDarkTheme: false,
    isNotificationsEnabled: false,
    username: "iamo0",
    userpic: "/public/iamo0.svg",
    preferredTheme: "monokai",
    favoriteHotels: [],
  });

  setUserSettings({
    ...userSettingsState,
    favoriteHotels: [...userSettingsState.favoriteHotels, "123"],
  });

  // Декларативный стиль — управление состоянием производится неявно
  // (в сторого определенном контролируемом контексте), а вызов изменения
  // состояния скорее является "запросом" на изменение этого состояния
  // чем прямым управлением
  const [userSettings, dispatch] = useReducer(userSettingsReducer, {
    isDarkTheme: false,
    isNotificationsEnabled: false,
    username: "iamo0",
    userpic: "/public/iamo0.svg",
    preferredTheme: "monokai",
    favoriteHotels: [],
  });

  dispatch({
    action: "ADD_FAVORITE_HOTEL",
    payload: {
      id: "123",
    },
  });
}
```

## Асинхронность и `useEffect`
Функция, обновляющая состояние, взятое из `useState` в React, асинхронна.
Когда меняется `state` компонента этот компонент нужно немедленно отрисовать 
заново. Отрисовка компонента заново в терминах функциональных компонент (
компонент-функция, те самое компоненты, которые мы обычно пишем) означает
новый вызов функции, это значит, что если обратиться к состоянию сразу 
после вызова функции обновления, в состоянии будет записано еще старое значение

```jsx
const [state, setState] = useState(0);
setState(1);
console.log(state); // вернет 0
```

Функция `useEffect` используется как обработчик события для наблюдения
за изменяемыми значениями, которые хранятся в `state`. После изменения
значения в `state`. Функция `useEffect` вызывается после каждого рендера 
(вызов функции), связанного с массивом значений (или с первым рендером
вообще). Поэтому, если вы используете `useEffect`, то первый его вызов
произойдет как только компонент отрисуется, а последующие — при изменении
значений массива зависимостей

```jsx
const [state, setState] = useState(0);
setState(1);

useEffect(function() {
  // Сработает два раза: вернет сначала 0, потом 1
  console.log(state);
});
```

## Трюк для условного рендеринга в React
Бывает так, что иногда вам нужно не отрисовывать определенный компонент
в зависимости от определенных условий

```jsx
// Неправильный подход, потому что тут генерируются два дерева
if (userIsLoggedIn) {
  return <header>
    Header stuff
  </header>
}

return <header>
  <Button>Log in</Button>
  Header stuff
</header>

```

Сравним два подхода к удалению элементов из дерева:

```
I. Прямое удаление
1 2 3 4 5
1 3 4 5
===
1 1
2 3
3 4
4 5
5

II. Пометка как удаленного
1 2    3 4 5
1 null 3 4 5

1 1
2 null
3 3
4 4
5 5
```

```jsx
return <header>
  Header stuff
  {isUserLoggedIn ?
    null :
    <Button>Log in</Button>}
</header>
```

## Загрузка данных в Next.js

1. Next.js — полноценный React-фреймворк (сервер, пагинатор, шаблонизатор, он
же — серверный ренденрер). За счет этого, Next.js старается по умолчанию
отрисовать все свои компоненты на сервере и на клиент отдать просто статику

```tsx
export default async function Page() {
  // В контексте Next.js это просто серверный код
  const response = await fetch("/api/messages");
  const messages = await response.json();

  return <section>
    {messages.map((m) => <article>{m.text}</article>)}
  </section>;
}
```

За счет такого подхода, использование запросов в теле неклиентских компонент
(не помеченных "use client") совершенно оправданно и никак не повлияет на 
производительность на стороне клиента, потому что будет совершаться во время
серверного рендеринга

## Роутинг в Next.js
В отличие от React Router который используется как библиотека, Next.js
это фреймворк (библиотека может встраиваться в любую архитектуру, фреймворк —
это физическое воплощение определенной архитектуры).

Next.js это фреймворк построенный вокруг React по двум основным принципам:
- Серверный рендеринг — максимально возможное количество кода отрисовывается
  именно во время запроса к серверу, а не на клиенте
- File-based роутинг. Вместо конфигурирования роутера как объекта на уровне
  кода
    - Вместо отдельного объекта используется определенная файловая стурктура. 
      Корневой роут обрабатывается файлом `page.tsx` который находится
      в папке, которая называется `app`
    - Чтобы задать вложенные урлы, нужно создать дополнительные папки внутри
      папки `app`
    - В Next.js существует система лейаутов, которая позволяет задавать для
      урлов соответствующие лейауты. Для этого нужно в директорию, которая
      отвечает за группу урлов поместить файл `layout.tsx`
        - Важное отличие лейаута в Next.js что он описывает страницу целиком
          потмоу что серверный рендеринг

> Next.js это file-based фреймворк, поэтому у него есть корнер-кейсы, которые приходится обходить тоже с помощью file-based трюков. Например, использование разных Root-лейаутов

## Зачем нужен SSR?
Если делать слишком большой упор на клиентском приложении, нужно учесть
два последствия:
1. Размер бандла JS который скачивает пользователь становится большим
  - Пользователь хоть и получает преимущество по скорости в момент выполнения сайта,
    он проигрывает на __первом__ скачивании
    - CI/CD. Если вы используете большой единый бандл, то он пересобирается целиком
      и получается так, что при обновлении кода, даже если была изменена 
      незначительная часть приложения, бандл будет пересобран целиком

2. Возникает проблема первого рендера
  - Негативный UI/UX
    - Частично компенсируется
      - Разделение кода на модули
      - Suspense/fallback
      - Более низкоуровневый прелоадер
  - Поисковики
    > Поисковики индексируют интернет. Это значит, что они заходят на все сайты, на которые существуют ссылки и сохраняют их у себя в кэше, предварительно прочитав их контент
      > Теоретически, можно разделить контент сайта на две части: на "контентную" (кешируемую поисковиками) и сервисную и написать их на разных технологиях, но это ухудшает DX (TTM)

## App Router vs Page Router
- до 13 версии в Next.js по умолчанию использовался Page Routing
  - Из-за требований обратной совместимости (т.к. Next.js давно уже практически
    стандарт де-факто для новых React проектов, поддержку Page Routing никто 
    не выпилил)

- в 13 версии создатели Next.js решили, что им больше нравится другая структура
  папок (app/<route-name>/page.tsx|layout.tsx) и назвали использование
  такой структуры папок App Router
