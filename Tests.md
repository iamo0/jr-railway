# Тесты

## Раннер

1. Тесты запускаются отдельно от приложения, потому что это параллельный слой разработки
2. Тесты запускаются с помощью инструмента, который называется test-runner. Самый популярный test runner для JS (по крайней мере в мире React) — jest
3. Тесты — это JS файлы, которые содержат код, с помощью которого можно убедиться в работоспособности кода вашего приложения (код проверяет другой код)

> Поскольку тесты это обычный код, важно помнить, что в них тоже можно допустить ошибку. Поэтому код тестов должен быть максимально простым и примитивным.

4. Тест-раннер находит все тестовые файлы и запускает их по очереди.

> Jest считает тестовыми файлы или файлы расположенные в директории `__tests__` на любом уровне вложенности или файлы содержащие в названии .test.js|ts или .spec.js|ts

## Тестовый фреймворк

5. В коде тестового файла должны находиться функции проверки, с помощью которых мы можем убедиться, что код, который мы проверяем работает правильно
6. Такие функции предоставляет инструмент, который называется тестовый фреймворк. Самый популярный тестовый фреймворк для JS (по крайней мере в мире React) — jest
7. Все тестовые фреймворки содержат функцию, которая помогает проверять код. Обычно эта функция называется `spec` или `it`
8. Функция spec (или it) вызывает свой коллбэк и тест считается пройденным, если внутри коллбэка не произошло ни одного Exception
9. В некоторых раннерах тесты можно группировать с помощью дополнительных функций. В jest это `describe`.

## assertion library

10. Простые проверки можно организрвать с помощью встроенных в язык функций сравнения и выбросить исключение в случае если эти проверки не проходят, однако...
11. Когда дело доходит до проверки в которой участвуют сложные типы данных, возможности языка становятся ограниченными и нужно писать сложные способы проверить результат выполнения функций
12. assertion-библиотека — это библиотека с набором функция для выполнения сложных проверок, например сравнения массивов
13. Самая популярная assertion-библиотека для JS (по крайней мере в мире React) — jest
14. assetion библиотека называется так, потому что она производит ассертивные проверки и если выражение не соответствует ожидаемому значению, проверка вызывает исключение
15. assertion библиотека в jest принимает выражения на проверку в chain-стиле

## Виды и уровни тестов
1. Код который мы пишем в тестах может быть совершенно лююбым. Поэтому то, какой код написан в тестах и что конкретно в нем тестируется — это уже вопрос дисциплины и договоренностей
2. Бывают разные виды тестов. Их можно сгруппировать, например по увеличению объема тестируемого кода или по среде запуска тестов (по виду тестируемых модулей)
  - Объем кода
    - Юнит-тесты — самые маленькие тесты. Проверяют функциональность одной конкретной единицы кода (например, функции или модуля)
      - helper-функции
      - вычисляемые части бизнес-логики
        - редьюсеры
        - вспомогательные функции, например, формирование сообщений об ошибках в форме
      - компоненты приложения
    - Интеграционные тесты — проверяют то, как между собой взаимодействуют несколько юнитов моего приложения
    - E2E тесты — (End to end, из конца в конец) — тесты законченных сценариев внутри приложения
      - регистрация
      - аутентификация
      - бронирование билета
      - отмена бронирования
  - Среда запуска
    - Node.js тесты (чистые функции, у которых можно проверить результат)
    - UI тесты — тесты, которые проверяют что UI приложения отображается корректно

> Когда вы пишете код с использованием тестов, он будет струткурирован так, чтобы отдельные части кода были тестируемыми, это вынуждает вас как разработчика лучше думать о модульности кода

## Среда запуска тестов и UI-тесты
1. Тесты — это просто JS-файлы, которые запускаются тест-раннером. Тест-раннер, как правило это node.js команда, стало быть, я легко могу тестировать код, который запускается в Node.js, но с тестированием всего связанного с браузером и браузерными библиотеками возникают проблемы

2. Логика UI-тестов выглядит следующим образом:
  - Отрисовываем компоненты с помощью рендерера (например, react-test-library)
  - Находим отрисованные компоненты в виртуальной странице (объект `screen` в RTL)
  - Проверяем их внешнее состояние с помощью `assertion`

3. Прикол UI-тестов заключается в том, что мы можем с их помощью проверять не только изначальное состояние элементов, но и влиять на них с помощью "событий". Пример — мы можем написать тест, который проверяет валидность компонента <SearchForm /> через прямые заполнения полей и клики по кнопкам

## Моки
Пример — отключение сетевых вызовов в библиотеках, делающих запросы по сети и использование фейковых функций вместо них

## E2E тестирование
1. Когда мы говорим про e2e тестирование немного размывается грань между людьми, которые пишут код и пишут тесты. Разработчики как правило пишут юнит-тесты и интеграционные тесты для обеспечения надежности своего кода. Но редко пишут тесты на проверку сценариев целиком (просто потому что обычно они сценариями даже и не думают). Поэтому e2e тестированием часто занимается отдельный человек — тестировщик

2. Самый частый вид тестировщика — ручной тестировщик. Это человек, который запускает приложение и прокликивает все сценарии своими руками

3. Когда объем тестов становится значительным, ручные тестировщики заменяются тестировщиками-кодерами, которые автоматизируют написание сценариев

4. Тестировщик — это отдельный человек. Чаще всего он не погружен в особенности того, как написан код. Тестировщик не знает фреймворк, язык, набор библиотек и т. д. что используется в коде разработчиками

5. Поэтому тестировщик пользуется отдельными инструментами для тестирования. Он не будет писать e2e тесты в Jest, просто потому что ему это неинтересно и в следующий день разработчики могут захотеть переехать на другой стек. Чаще всего этот инструмент — Cypress.

6. Cypress — агностичен относительно стека, который используется на проекте. Cypress имитирует браузер, который ходит по определенным урлам в приложении